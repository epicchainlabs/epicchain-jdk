package io.neow3j.crypto;

import org.bouncycastle.util.encoders.Hex;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

import java.io.IOException;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.assertArrayEquals;
import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * Unit tests for {@link MnemonicUtils} utility class.
 */
public class MnemonicUtilsTest {

    /**
     * Path to test vectors generated by the BIP 39 reference implementation. Each
     * test vector include input entropy, mnemonic and seed. The passphrase "TREZOR"
     * is used for all vectors.
     *
     * @see <a href="https://github.com/trezor/python-mnemonic/blob/master/vectors.json">Test vectors</a>
     */
    private static final URL SAMPLE_FILE = MnemonicUtilsTest.class.getResource("/mnemonics/test-vectors.txt");

    /**
     * Loads the test vectors into a in-memory list and feed them one after another to our parameterized tests.
     * <p>
     * Test vectors are split by "###" and consist of the initial entropy, the mnemonic sequence and the binary seed
     * on separate lines.
     * <p>
     * The initial entropy should be used to generate mnemonic and seed. The read mnemonic is the expected outcome
     * when generating the mnemonic from initial entropy. Finally, the binary seed is the expected seed based on the
     * calculated mnemonic and default passphrase.
     *
     * @return Collection of test vectors in which each vector is an array containing initial entropy, expected
     * mnemonic and expected seed.
     * @throws IOException Shouldn't happen!
     */
    private static Stream<Arguments> data() throws IOException, URISyntaxException {
        String data = Files.lines(Paths.get(SAMPLE_FILE.toURI())).collect(Collectors.joining("\n"));
        String[] mnemonicSets = data.split("###");

        return Arrays.stream(mnemonicSets)
                .map(String::trim)
                .map(trimmed -> trimmed.split("\n"))
                .map(Arguments::of);
    }

    @ParameterizedTest
    @MethodSource("data")
    public void generateMnemonicShouldGenerateExpectedMnemonicWords(String initialEntropy, String mnemonic) {
        String actualMnemonic = MnemonicUtils.generateMnemonic(Hex.decode(initialEntropy));

        assertEquals(mnemonic, actualMnemonic);
    }

    @ParameterizedTest
    @MethodSource("data")
    public void generateSeedShouldGenerateExpectedSeeds(String initialEntropy, String mnemonic, String seed) {
        byte[] actualSeed = MnemonicUtils.generateSeed(mnemonic, "TREZOR");

        assertArrayEquals(Hex.decode(seed), actualSeed);
    }

    @ParameterizedTest
    @MethodSource("data")
    public void generateEntropyShouldGenerateExpectedEntropy(String initialEntropy, String mnemonic, String seed) {
        byte[] actualEntropy = MnemonicUtils.generateEntropy(mnemonic);

        assertArrayEquals(Hex.decode(initialEntropy), actualEntropy);
    }

}
